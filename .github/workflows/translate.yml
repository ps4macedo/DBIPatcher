name: Build (translate)

on:
  push:
    branches:
      - '**'
    paths-ignore:
      - '**/*.md'
      - LICENSE
      - .gitignore
      - .gitattributes
      - dbipatcher.log
  pull_request:
    paths-ignore:
      - '**/*.md'
      - LICENSE
      - .gitignore
      - .gitattributes
      - dbipatcher.log
  workflow_dispatch:

permissions:
  contents: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    env:
      CONFIG_FILE: config.txt
    outputs:
      matrix: ${{ steps.prepare-matrix.outputs.matrix }}
      ver: ${{ steps.read-config.outputs.ver }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - id: read-config
        name: Read config
        shell: bash
        run: |
          set -euo pipefail
          TARGET=$(awk -F= '/^[[:space:]]*target_lang[[:space:]]*=/{gsub(/^[ 	]+|[ 	]+$/,"",$2);print $2}' "${CONFIG_FILE}" 2>/dev/null | tr -d '')
          VER=$(awk -F= '/^[[:space:]]*ver[[:space:]]*=/{gsub(/^[ 	]+|[ 	]+$/,"",$2);print $2}' "${CONFIG_FILE}" 2>/dev/null | tr -d '')
          [ -n "$TARGET" ] || TARGET="en"
          [ -n "$VER" ] || VER="821"
          echo "target=$TARGET" >> "$GITHUB_OUTPUT"
          echo "ver=$VER" >> "$GITHUB_OUTPUT"

      - id: prepare-matrix
        name: Prepare matrix
        env:
          TARGET_VAL: ${{ steps.read-config.outputs.target }}
        shell: bash
        run: |
          python3 - <<'PY' >> "$GITHUB_OUTPUT"
          import glob, json, os, sys
          target = (os.environ.get("TARGET_VAL") or "").strip() or "en"
          include = []
          if target.lower() == "all":
              files = sorted(glob.glob("translate/rec*.txt"))
              if not files:
                  print("::error::No translation files found in translate/rec*.txt", file=sys.stderr)
                  sys.exit(1)
              seen = set()
              for path in files:
                  base = os.path.basename(path)
                  parts = base.split(".")
                  if len(parts) < 3:
                      continue
                  lang = ".".join(parts[1:-1]).strip()
                  if not lang or lang.lower() == "ru":
                      continue
                  if lang in seen:
                      continue
                  seen.add(lang)
                  include.append({"target": lang})
          else:
              if target.lower() == "ru":
                  print("::warning::target_lang=ru skipped because base language is already Russian", file=sys.stderr)
              else:
                  include.append({"target": target})
          if not include:
              print("::error::No target languages resolved from configuration", file=sys.stderr)
              sys.exit(1)
          print(f"matrix={json.dumps({'include': include})}")
          PY

  build:
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.prepare.outputs.matrix) }}
    env:
      CONFIG_FILE: config.txt
      DBI_VER: ${{ needs.prepare.outputs.ver }}
      DBI_TARGET: ${{ matrix.target }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install deps
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential zstd libzstd-dev lz4 gzip binutils

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-v1
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python deps
        shell: bash
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install zstandard

      - name: Build dbipatcher
        shell: bash
        run: |
          set -euo pipefail
          echo "[1/5] Build dbipatcher"
          make -j bin/dbipatcher || make -j dbipatcher

      - name: Extract NRO
        shell: bash
        run: |
          set -euo pipefail
          echo "[2/5] Extraindo NRO do ${DBI_VER}"
          ./bin/dbipatcher --extract "dbi/DBI.${DBI_VER}.ru.nro" --output "/tmp/DBI_${DBI_VER}"

      - name: Probe rec blobs (dump + try decompress + strings)
        shell: bash
        run: |
          set -euo pipefail
          echo "[3/5] Probe dos rec*.bin"
          mkdir -p debug_rec
          for i in $(seq 0 9); do
            IN="/tmp/DBI_${DBI_VER}/rec${i}.bin"
            [ -f "$IN" ] || continue
            cp "$IN" "debug_rec/rec${i}.bin"
            head -c 16 "$IN" | od -An -tx1 > "debug_rec/rec${i}.magic.txt" || true
            for mode in raw zstd gzip lz4 zlib zlibraw deflate; do
              OUT="debug_rec/rec${i}.${mode}.bin"
              case "$mode" in
                raw)
                  cp "$IN" "$OUT"
                  ;;
                zstd)
                  zstd -q -d -c "$IN" > "$OUT" 2>/dev/null || rm -f "$OUT"
                  ;;
                gzip)
                  gzip -q -dc "$IN" > "$OUT" 2>/dev/null || rm -f "$OUT"
                  ;;
                lz4)
                  lz4 -q -d -c "$IN" > "$OUT" 2>/dev/null || rm -f "$OUT"
                  ;;
                zlib)
                  python3 - <<'PY' "$IN" "$OUT" || true
import sys, zlib, pathlib
p = pathlib.Path(sys.argv[1]).read_bytes()
try:
    out = zlib.decompress(p)
    pathlib.Path(sys.argv[2]).write_bytes(out)
except Exception:
    pass
PY
                  [ -s "$OUT" ] || rm -f "$OUT"
                  ;;
                zlibraw)
                  python3 - <<'PY' "$IN" "$OUT" || true
import sys, zlib, pathlib
p = pathlib.Path(sys.argv[1]).read_bytes()
ok = False
for w in (-15,-14,-13,-12):
    try:
        out = zlib.decompress(p, wbits=w)
        pathlib.Path(sys.argv[2]).write_bytes(out)
        ok = True
        break
    except Exception:
        pass
sys.exit(0 if ok else 1)
PY
                  [ -s "$OUT" ] || rm -f "$OUT"
                  ;;
                deflate)
                  python3 - <<'PY' "$IN" "$OUT" || true
import sys, zlib, pathlib
p = pathlib.Path(sys.argv[1]).read_bytes()
try:
    d = zlib.decompressobj(-zlib.MAX_WBITS)
    out = d.decompress(p) + d.flush()
    pathlib.Path(sys.argv[2]).write_bytes(out)
except Exception:
    pass
PY
                  [ -s "$OUT" ] || rm -f "$OUT"
                  ;;
              esac
              if [ -f "$OUT" ]; then
                strings -a -n 3 "$OUT" | head -n 200 > "debug_rec/rec${i}.${mode}.strings.txt" || true
                ./bin/dbipatcher --convert "$OUT" --output "debug_rec/rec${i}.${mode}.ru.txt"                   > "debug_rec/rec${i}.${mode}.convert.log" 2>&1 || true
              fi
            done
          done

      - name: Upload rec probe
        uses: actions/upload-artifact@v4
        with:
          name: rec_probe_${{ matrix.target }}
          path: debug_rec/**
          if-no-files-found: warn

      - name: Detect & translate (auto-detect REC)
        shell: bash
        run: |
          set -euo pipefail
          echo "[4/5] Detectando slot de texto (recX)"
          DETECTED=""
          for i in $(seq 0 9); do
            IN="/tmp/DBI_${DBI_VER}/rec${i}.bin"
            OUT="translate/rec${i}.ru.txt"
            [ -f "$IN" ] || continue
            rm -f "$OUT"
            if ./bin/dbipatcher --convert "$IN" --output "$OUT" >"/tmp/probe_rec${i}.log" 2>&1; then
              if [ -s "$OUT" ] && grep -qE '^[A-Za-z0-9_]+[[:space:]]*=' "$OUT"; then
                echo ">> Texto detectado em rec${i}"
                DETECTED="$i"; break
              fi
            fi
          done
          if [ -z "$DETECTED" ]; then
            echo "::warning::Nenhum recX legível detectado; veja o artefato rec_probe_* para análise."
            # Não falha o job aqui para permitir baixar o artefato. Remova a linha abaixo se quiser falhar.
            DETECTED="0"
          fi

          echo "[ajuste] Garantindo translate/rec${DETECTED}.ptbr.txt"
          if [ ! -f "translate/rec${DETECTED}.ptbr.txt" ]; then
            for f in translate/rec*.ptbr.txt; do
              [ -e "$f" ] || continue
              mv "$f" "translate/rec${DETECTED}.ptbr.txt"
              break
            done
          fi
          [ -f "translate/rec${DETECTED}.ptbr.txt" ] || : > "translate/rec${DETECTED}.ptbr.txt"

          echo "[5/5] Rodando translate com REC=${DETECTED}"
          LANG="${DBI_TARGET}" make translate REC="${DETECTED}" || true

      - name: Prepare artifact
        shell: bash
        run: |
          set -euo pipefail
          rm -rf artifacts
          mkdir -p artifacts
          if [ -f "out/dbi/DBI.${DBI_VER}.${DBI_TARGET}.nro" ]; then
            cp "out/dbi/DBI.${DBI_VER}.${DBI_TARGET}.nro" artifacts/
          fi

      - name: Upload artifact (DBI.zip contains only the NRO)
        uses: actions/upload-artifact@v4
        with:
          name: DBI_${{ matrix.target }}
          path: artifacts/**
          if-no-files-found: warn
          retention-days: 7

  release:
    needs: [prepare, build]
    if: ${{ github.event_name != 'pull_request' }}
    runs-on: ubuntu-latest
    env:
      DBI_VER: ${{ needs.prepare.outputs.ver }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist
          pattern: DBI_*
          merge-multiple: true

      - name: Flatten artifacts
        shell: bash
        run: |
          python3 - <<'PY'
          import shutil, sys
          from pathlib import Path
          dist = Path("dist")
          if not dist.exists():
              print("::error::Downloaded artifacts directory not found", file=sys.stderr); sys.exit(1)
          files = list(dist.rglob("*.nro"))
          if not files:
              print("::warning::No .nro files found in dist (build may have only probed rec).", file=sys.stderr)
              sys.exit(0)
          tmp = Path("dist_flat")
          if tmp.exists(): shutil.rmtree(tmp)
          tmp.mkdir(parents=True, exist_ok=True)
          for f in files: shutil.copy2(f, tmp / f.name)
          shutil.rmtree(dist)
          tmp.rename(dist)
          PY

      - name: Prepare release metadata
        id: meta
        shell: bash
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          TAG="dbi-${DBI_VER}-${SHORT_SHA}"
          NAME="DBI ${DBI_VER} (${SHORT_SHA})"
          printf 'tag=%s
' "$TAG"  >> "$GITHUB_OUTPUT"
          printf 'name=%s
' "$NAME" >> "$GITHUB_OUTPUT"

      - name: Generate changelog
        shell: bash
        run: |
          LAST_TAG=$(git describe --tags --match 'dbi-*' --abbrev=0 2>/dev/null || echo '')
          if [ -n "$LAST_TAG" ]; then RANGE="$LAST_TAG..HEAD"; else RANGE="HEAD^..HEAD"; fi
          git log "$RANGE" --pretty=format:'- %s (%h)' > CHANGELOG.log || true
          [ -s CHANGELOG.log ] || git log -1 --pretty=format:'- %s (%h)' > CHANGELOG.log
          TAG_NAME=${{ steps.meta.outputs.tag }}
          {
            printf '![GitHub release (tag)](https://img.shields.io/github/downloads/rashevskyv/DBIPatcher/%s/total)

' "$TAG_NAME"
            printf '### Changelog

'
            cat CHANGELOG.log
            printf '
'
          } > CHANGELOG.md
          rm -f CHANGELOG.log

      - name: Create release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ steps.meta.outputs.tag }}
          name: ${{ steps.meta.outputs.name }}
          bodyFile: CHANGELOG.md
          artifacts: dist/*.nro
          artifactErrorsFailBuild: true
          allowUpdates: true
          makeLatest: true
